// 测试链接 : https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb

// 解题思路
// 问题转化：
// 将原数组中的正数转为1，负数转为-1，0保持为0
// 这样问题就变成了：找到和为0的最长子数组
// 前缀和 + 哈希表：
// 使用前缀和数组记录从开始到当前位置的累计和
// 使用哈希表记录每个前缀和第一次出现的位置
// 当遇到重复的前缀和时，说明中间这段子数组的和为0，也就是正负数相等
// 具体实现：
// 初始化哈希表，放入(0, -1)表示初始位置前的前缀和为0
// 遍历数组，计算前缀和
// 如果当前前缀和在哈希表中已存在，说明找到了一个正负数相等的子数组
// 计算子数组长度，更新最大长度
// 如果当前前缀和不存在于哈希表，则将其加入哈希表
// 为什么有效：
// 如果两个位置的前缀和相同，说明这两个位置之间的子数组和为0
// 对于转换后的数组，和为0意味着正数(1)和负数(-1)的个数相等
// 我们只需记录每个前缀和第一次出现的位置，这样可以找到最长的子数组
// 时间复杂度：O(n)，只需遍历一次数组
// 空间复杂度：O(n)，哈希表最多存储n个不同的前缀和
// 这是一个经典的前缀和+哈希表问题，通过巧妙的转换，将"正负数个数相等"转化为"子数组和为0"，然后用前缀和技巧高效求解。


#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

int main() {
   int N;
   cin >> N;
   vector<int> nums(N);    //* 使用resize后再进行追加会追加再N后面
   // 正确读取数组
   for(int i = 0; i < N; i++){
      cin >> nums[i];
      // 直接在读取时进行转换
      nums[i] = nums[i] != 0 ? (nums[i] > 0 ? 1 : -1) : 0;
   }
   int ans = 0;
   int sum = 0;
   unordered_map<int,int> map;
   map[0] = -1;
   for(int i = 0; i < N; i++){
      sum += nums[i];
      if(map.find(sum) != map.end()){
         ans = max(ans , i - map[sum]);
      }
      else{
         map[sum] = i;
      }
   }
   cout << ans;
   return 0;
}
// 64 位输出请用 printf("%lld")

